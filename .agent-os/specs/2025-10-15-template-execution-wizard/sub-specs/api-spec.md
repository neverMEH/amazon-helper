# API Specification

This is the API specification for the spec detailed in @.agent-os/specs/2025-10-15-template-execution-wizard/spec.md

## Endpoints

### POST /api/instances/{instance_id}/templates/{template_id}/execute

**Purpose:** Execute an instance template immediately (run once) with specified date range and optional Snowflake integration.

**Authentication:** Required (JWT token)

**Path Parameters:**
- `instance_id` (string, UUID): The instance UUID (not the AMC instance string ID)
- `template_id` (string): The template ID (format: `tpl_inst_<12-char-hex>`)

**Request Body:**
```json
{
  "name": "Nike Brand - Top Products Analysis - 2025-10-01 - 2025-10-31",
  "timeWindowStart": "2025-10-01",
  "timeWindowEnd": "2025-10-31",
  "snowflake_enabled": true,
  "snowflake_table_name": "amc_top_products",
  "snowflake_schema_name": "analytics"
}
```

**Request Schema:**
```typescript
{
  name: string;                      // 1-500 characters, auto-generated by frontend
  timeWindowStart: string;           // ISO date format: YYYY-MM-DD
  timeWindowEnd: string;             // ISO date format: YYYY-MM-DD
  snowflake_enabled?: boolean;       // Optional, default false
  snowflake_table_name?: string;     // Optional, auto-generated if empty
  snowflake_schema_name?: string;    // Optional, uses default if empty
}
```

**Response (201 Created):**
```json
{
  "workflow_execution_id": "550e8400-e29b-41d4-a716-446655440000",
  "amc_execution_id": "ae12345678",
  "status": "PENDING",
  "created_at": "2025-10-15T14:30:00Z"
}
```

**Response Schema:**
```typescript
{
  workflow_execution_id: string;     // UUID of the created workflow execution
  amc_execution_id: string | null;   // AMC execution ID (null if AMC call failed)
  status: string;                     // "PENDING" | "RUNNING" | "FAILED"
  created_at: string;                 // ISO 8601 timestamp
}
```

**Error Responses:**

**400 Bad Request** - Invalid request data
```json
{
  "detail": [
    {
      "loc": ["body", "timeWindowStart"],
      "msg": "field required",
      "type": "value_error.missing"
    }
  ]
}
```

**401 Unauthorized** - Missing or invalid JWT token
```json
{
  "detail": "Not authenticated"
}
```

**404 Not Found** - Template or instance not found
```json
{
  "detail": "Template not found or access denied"
}
```

**500 Internal Server Error** - Server error during execution creation
```json
{
  "detail": "Failed to create workflow execution: <error details>"
}
```

**Business Logic:**
1. Validate JWT token and extract `user_id`
2. Fetch template from `instance_templates` table
3. Verify template ownership (`template.user_id === user_id`)
4. Fetch instance with joined `amc_accounts` table to get `entity_id`
5. Call AMC API to create workflow execution with:
   - SQL query from template
   - Time window from request
   - Empty parameters object (templates don't use parameters)
6. Store execution record in `workflow_executions` table with:
   - Execution metadata (template info, Snowflake config)
   - Initial status: PENDING
7. Return execution details for frontend navigation

**Implementation Notes:**
- Uses `amc_api_client_with_retry` for resilient AMC API calls
- Stores Snowflake configuration in `metadata` JSONB field
- Auto-increment template `usage_count` (handled by separate endpoint)
- Execution will be picked up by background polling service

---

### POST /api/instances/{instance_id}/templates/{template_id}/schedule

**Purpose:** Create a recurring schedule for an instance template with rolling date range support.

**Authentication:** Required (JWT token)

**Path Parameters:**
- `instance_id` (string, UUID): The instance UUID
- `template_id` (string): The template ID (format: `tpl_inst_<12-char-hex>`)

**Request Body:**
```json
{
  "name": "Nike Brand - Weekly Top Products - Rolling 30 Days",
  "schedule_config": {
    "frequency": "weekly",
    "time": "09:00",
    "lookback_days": 30,
    "date_range_type": "rolling",
    "window_size_days": 30,
    "timezone": "America/New_York",
    "day_of_week": 1
  }
}
```

**Request Schema:**
```typescript
{
  name: string;                      // 1-500 characters, auto-generated by frontend
  schedule_config: {
    frequency: 'daily' | 'weekly' | 'monthly';  // Required
    time: string;                    // Required, HH:mm format (e.g., "09:00")
    lookback_days?: number;          // Optional, 1-365
    date_range_type?: 'rolling' | 'fixed';  // Optional
    window_size_days?: number;       // Optional, 1-365 (alias for lookback_days)
    timezone: string;                // Required (e.g., "America/New_York")
    day_of_week?: number;            // For weekly: 0-6 (0=Sunday)
    day_of_month?: number;           // For monthly: 1-31
  }
}
```

**Response (201 Created):**
```json
{
  "schedule_id": "sched_123abc456def",
  "workflow_id": "wf_789ghi012jkl",
  "next_run_at": "2025-10-22T09:00:00-04:00",
  "created_at": "2025-10-15T14:30:00Z"
}
```

**Response Schema:**
```typescript
{
  schedule_id: string;               // Schedule ID (format: sched_<random>)
  workflow_id: string;               // Created workflow ID
  next_run_at: string | null;        // ISO 8601 timestamp of next execution
  created_at: string;                // ISO 8601 timestamp
}
```

**Error Responses:**

**400 Bad Request** - Invalid schedule configuration
```json
{
  "detail": [
    {
      "loc": ["body", "schedule_config", "frequency"],
      "msg": "string does not match regex \"^(daily|weekly|monthly)$\"",
      "type": "value_error.str.regex"
    }
  ]
}
```

**401 Unauthorized** - Missing or invalid JWT token
```json
{
  "detail": "Not authenticated"
}
```

**404 Not Found** - Template or instance not found
```json
{
  "detail": "Template not found or access denied"
}
```

**422 Unprocessable Entity** - Invalid schedule configuration
```json
{
  "detail": "lookback_days must be between 1 and 365"
}
```

**500 Internal Server Error** - Server error during schedule creation
```json
{
  "detail": "Failed to create schedule: <error details>"
}
```

**Business Logic:**
1. Validate JWT token and extract `user_id`
2. Fetch template from `instance_templates` table
3. Verify template ownership (`template.user_id === user_id`)
4. Create workflow record:
   - Copy SQL query from template
   - Set metadata with template reference
   - Associate with instance
5. Create schedule record:
   - Link to created workflow
   - Apply schedule configuration
   - Calculate `next_run_at` based on frequency and timezone
   - Set initial state: `is_active = true`
6. Return schedule details for frontend navigation

**Schedule Execution Behavior:**
- Schedule executor service runs every 60 seconds
- Checks `next_run_at` against current time in configured timezone
- For rolling date ranges:
  - Calculates `timeWindowEnd` as: execution_date - 14 days (AMC lag)
  - Calculates `timeWindowStart` as: timeWindowEnd - lookback_days
- Creates workflow execution with calculated dates
- Updates `next_run_at` for next execution

**Implementation Notes:**
- Uses `WorkflowService.create_workflow()` for workflow creation
- Uses `ScheduleService.create_schedule()` for schedule creation
- Stores template reference in workflow metadata
- Schedule will be picked up by schedule executor background service
- Supports all existing schedule features (notifications, cost limits, etc.)

---

## Error Handling Standards

### Validation Errors (400/422)
- Use FastAPI's automatic Pydantic validation
- Return structured error messages with field locations
- Include helpful error messages (not just "field required")

### Authentication Errors (401)
- Verify JWT token in all endpoints
- Return standard "Not authenticated" message
- Do not leak information about which resources exist

### Authorization Errors (404)
- Verify user owns the template (`template.user_id === user_id`)
- Return generic "not found" message (don't distinguish ownership vs. non-existence)
- Prevents enumeration of other users' templates

### Server Errors (500)
- Log detailed error information server-side
- Return sanitized error message to client
- Include request ID for debugging (if available)

---

## Security Considerations

1. **Template Ownership Verification**:
   - Always check `template.user_id === user_id` before execution
   - Prevents users from executing other users' templates

2. **Instance Access Control**:
   - Verify user has access to the instance
   - Check through instance-user relationships or RLS policies

3. **SQL Injection Protection**:
   - Templates execute their saved SQL as-is (no modification)
   - SQL is validated when template is created
   - No user input is interpolated into SQL

4. **Rate Limiting** (Future Enhancement):
   - Consider adding rate limits for execution endpoint
   - Prevent abuse of immediate execution feature

5. **Snowflake Credentials**:
   - Stored securely in backend environment variables
   - Never exposed to frontend
   - Used only by backend upload service

---

## Database Schema Impact

### New Fields Required

**workflow_executions table:**
No changes required. Uses existing `metadata` JSONB field for:
```json
{
  "execution_name": "Nike Brand - Top Products Analysis - 2025-10-01 - 2025-10-31",
  "template_id": "tpl_inst_abc123def456",
  "template_name": "Top Products Analysis",
  "snowflake_enabled": true,
  "snowflake_table_name": "amc_top_products",
  "snowflake_schema_name": "analytics"
}
```

**workflows table:**
No changes required. Uses existing `metadata` JSONB field for:
```json
{
  "source": "instance_template",
  "template_id": "tpl_inst_abc123def456",
  "template_name": "Top Products Analysis"
}
```

**workflow_schedules table:**
No changes required. Already supports:
- `lookback_days` field (1-365)
- `date_range_type` field ('rolling' | 'fixed')
- `window_size_days` field (1-365)

---

## Integration with Existing Systems

### AMC API Integration
- Uses existing `amc_api_client_with_retry` service
- Follows same patterns as WorkflowService
- Includes automatic retry on transient failures

### Schedule Executor Service
- No changes required
- Will automatically pick up new schedules
- Calculates rolling dates as expected

### Execution Polling Service
- No changes required
- Will automatically poll new executions
- Updates status from AMC API

### Snowflake Upload Service
- Reuses existing upload logic from report builder
- Triggered by execution completion webhook
- Reads config from execution metadata

---

## Testing Requirements

### Unit Tests
1. Template ownership verification
2. Instance access verification
3. Auto-generated name format
4. Date range validation
5. Schedule configuration validation

### Integration Tests
1. End-to-end execution flow (create → execute → poll → complete)
2. End-to-end schedule flow (create → trigger → execute)
3. Snowflake upload integration
4. AMC API failure handling

### Manual Testing
1. Execute template with various date ranges
2. Create daily/weekly/monthly schedules
3. Verify executions appear in Executions page
4. Verify schedules appear in Schedules page
5. Test Snowflake upload with real credentials

---

## Performance Metrics

### Target Response Times
- Execute endpoint: < 2 seconds (includes AMC API call)
- Schedule endpoint: < 500ms (database operations only)

### Expected Load
- Execute: ~100 requests/hour per user
- Schedule: ~20 requests/hour per user

### Monitoring
- Track AMC API call success rate
- Monitor execution creation failures
- Alert on schedule creation failures
